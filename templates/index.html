<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <img src="path/to/your/logo.jpg" alt="Company Logo" class="circular-image">
     <style>
        .circular-image {
            width: 150px; /* Set a specific width */
            height: 150px; /* Make height equal to width for a perfect circle */
            border-radius: 50%; /* This makes it a circle */
            object-fit: cover; /* Ensures the image covers the circle without distortion */
            /* Optional: Add a border */
            border: 3px solid #333;
        }
    </style>
    <title>NOVA-R</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #181820;
            color: #e0e0e0;
            margin: 0;
            min-height: 100vh;
            width: 100vw;
            box-sizing: border-box;
            overflow: hidden;
            position: relative;
        }
        #background-anim {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .chat-outer {
            position: relative;
            width: 100vw;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 1;
        }
        .chat-container {
            max-width: 100vw;
            width: 100vw;
            margin: 0 auto;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            padding: 0 2.5vw;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        .chat-canvas {
            background: #252525ff;
            opacity: 0.75;
            border-radius: 1.5rem;
            box-shadow: 0 4px 24px 0 rgba(80, 60, 120, 0.13);
            padding: 1.5rem 1.5vw 1.5rem 1.5vw;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            width: 100%;
            max-width: 100vw;
            height: 580px;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .chat-header {
            display: none;
        }
        .chat-messages {
            flex-grow: 1;
            padding: 0 0 0 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0;
            font-size: 1.15rem;
            background: transparent;
            scrollbar-width: none;
        }
        .chat-messages::-webkit-scrollbar {
            display: none;
        }
        .message-row {
            width: 100%;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: row;
        }
        .agent-message {
            background: none !important;
            color: #a78bfa !important;
            border-radius: 0;
            padding: 1.3rem 0 1.3rem 0;
            margin: 0;
            width: 100%;
            border: none;
            font-size: 1.13rem;
            font-family: inherit;
            white-space: pre-line;
            text-align: left;
        }
        .user-message {
            background: #9333ea 100%;
            color: #fff !important;
            border-radius: 1.3rem 1.3rem 0.2rem 1.3rem;
            padding: 1.1rem 1.5rem 1.1rem 1.5rem;
            margin: 0.5rem 0 0.5rem auto;
            max-width: 70%;
            text-align: right;
            border: none;
            font-size: 1.13rem;
            font-family: inherit;
            white-space: pre-line;
            box-shadow: 0 2px 12px 0 rgba(147,51,234,0.10);
            display: inline-block;
        }
        .chat-input-area {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding: 2.2rem 0 2.7rem 0;
            border: none;
            background: transparent;
        }
        .chat-input-bar {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 900px;
            background: rgba(40,40,48,0.92);
            border-radius: 2.5rem;
            border: 1.5px solid #3a2a5a;
            box-shadow: 0 2px 16px 0 rgba(80,60,120,0.10);
            padding: 0.2rem 1.2rem 0.2rem 1.2rem;
            gap: 0.7rem;
        }
        .chat-input {
            flex: 1 1 auto;
            background: transparent;
            border: none;
            outline: none;
            color: #e0e0e0;
            font-size: 1.18rem;
            padding: 1.1rem 0.5rem 1.1rem 0.5rem;
            min-width: 0;
        }
        .chat-input::placeholder {
            color: #a0a0a0;
            font-size: 1.18rem;
        }
        .chat-attach-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
            margin-right: 0.2rem;
            transition: background 0.18s, box-shadow 0.18s;
        }
        .chat-attach-btn:hover {
            background: #2d1a4a;
            box-shadow: 0 2px 12px 0 rgba(147,51,234,0.18);
        }
        .chat-attach-btn svg {
            width: 1.3rem;
            height: 1.3rem;
            color: #fff;
        }
        .send-button {
            background-color: #9333ea;
            color: white;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
            font-size: 1.35rem;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-left: 0.2rem;
        }
        .send-button:hover {
            background-color: #a78bfa;
        }
        .chat-input::placeholder {
            color: #a0a0a0;
        }
        .chat-input:focus {
            border-color: #9333ea;
        }
        .send-button {
            background-color: #9333ea;
            color: white;
            width: 2.7rem;
            height: 2.7rem;
            border-radius: 50%;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
            font-size: 1.35rem;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .send-button:hover {
            background-color: #7e22ce;
            transform: translateY(-1px);
        }
        .send-button:active {
            transform: translateY(0);
        }
        .chat-footer-fixed {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100vw;
            z-index: 10;
            background: transparent;
            padding: 0.7rem 2.5vw 1.2rem 2.5vw;
            border: none;
            display: flex;
            align-items: center;
            gap: 0.7rem;
        }
        @media (max-width: 640px) {
            .chat-canvas {
                padding: 0.7rem 1vw 0.7rem 1vw;
                border-radius: 0.7rem;
            }
            .chat-footer-fixed {
                padding: 0.5rem 1vw 0.7rem 1vw;
            }
            .chat-container {
                padding: 0 1vw;
            }
        }
        </style>
</head>
<body>
        <div id="background-anim">
            <header style="position:absolute;left:2.5vw;z-index:2;text-align:left;">
                <div style="color:#fff;font-size:2.1rem;font-weight:700;line-height:1.2;margin-top:0.2em;">NOVA-R</div>
            </header>
        </div>

        <div class="chat-outer" style="margin-top:2rem;">
            <div class="chat-container" style="height:100%;">
                <div class="chat-canvas">
                    <main id="chatMessages" class="chat-messages">
                        <div style="color:#b794f4;font-size:1.25rem;font-weight:500;line-height:1.2;">Hello! I'm Nova, your AI Assistant. How can I help you today?</div>
                        <!-- Messages will appear here -->
                    </main>
                </div>
            </div>
        </div>
        <footer class="chat-input-area chat-footer-fixed">
            <form class="chat-input-bar" onsubmit="event.preventDefault(); sendMessage();">
                <button class="chat-attach-btn" type="button" title="Attach file" onclick="document.getElementById('file-upload-area').click()">
                    <svg viewBox="0 0 20 20" fill="none"><circle cx="10" cy="10" r="9" stroke="#fff" stroke-width="2"/><path d="M10 6v8M6 10h8" stroke="#fff" stroke-width="2" stroke-linecap="round"/></svg>
                </button>
                <input id="file-upload-area" type="file" style="display:none" multiple accept="image/*,application/pdf,.doc,.docx,.txt,.csv,.xlsx,.zip,.rar">
                <input id="queryInput" class="chat-input" type="text" placeholder="Ask anything" autofocus>
                <button id="sendButton" class="send-button" aria-label="Send" type="submit">
                    <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="11" cy="11" r="11" fill="none"/>
                        <path d="M6 12L11 7L16 12" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </form>
        </footer>
    <script>
        // --- Enhanced Animated background using DOM elements (no canvas) ---
        // This section is unchanged and remains as it was.
        const bgAnim = document.getElementById('background-anim');
        const numPoints = 48;
        const connectionDistance = 150;
        let points = [];
        function randomBetween(a, b) { return Math.random() * (b - a) + a; }
        
        function createPoint() {
            const el = document.createElement('div');
            el.className = 'bg-point';
            const radius = randomBetween(1.2, 3.5);
            el.style.width = el.style.height = radius * 2 + 'px';
            const hues = [240, 265, 280, 290];
            const h = hues[Math.floor(Math.random() * hues.length)];
            el.style.background = 'hsla(' + h + ', 80%, 65%, ' + randomBetween(0.18, 0.45) + ')';
            bgAnim.appendChild(el);
            return {
                el,
                x: randomBetween(0, window.innerWidth),
                y: randomBetween(0, window.innerHeight),
                vx: randomBetween(-0.7, 0.7),
                vy: randomBetween(-0.7, 0.7),
                r: radius
            };
        }

        function updatePoint(p) {
            p.x += p.vx; p.y += p.vy;
            if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
            if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
            p.x = Math.max(0, Math.min(window.innerWidth, p.x));
            p.y = Math.max(0, Math.min(window.innerHeight, p.y));
            p.el.style.transform = `translate(${p.x - p.r}px, ${p.y - p.r}px)`;
        }

        let triangles = [];
        function clearTriangles() {
            for (const t of triangles) bgAnim.removeChild(t);
            triangles = [];
        }

        function drawTriangle(p1, p2, p3, opacity) {
            const svgNS = 'http://www.w3.org/2000/svg';
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', window.innerWidth);
            svg.setAttribute('height', window.innerHeight);
            svg.style.position = 'absolute'; svg.style.left = '0'; svg.style.top = '0';
            svg.style.pointerEvents = 'none'; svg.style.zIndex = -1;
            const poly = document.createElementNS(svgNS, 'polygon');
            poly.setAttribute('points', `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`);
            poly.setAttribute('fill', 'rgba(147,51,234,' + (opacity * 0.18) + ')');
            poly.setAttribute('stroke', 'rgba(147,51,234,' + (opacity * 0.45) + ')');
            poly.setAttribute('stroke-width', '1.2');
            svg.appendChild(poly);
            triangles.push(svg);
            bgAnim.appendChild(svg);
        }

        function animateBG() {
            points.forEach(updatePoint);
            clearTriangles();
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    for (let k = j + 1; k < points.length; k++) {
                        const d1 = Math.hypot(points[i].x - points[j].x, points[i].y - points[j].y);
                        const d2 = Math.hypot(points[j].x - points[k].x, points[j].y - points[k].y);
                        const d3 = Math.hypot(points[k].x - points[i].x, points[k].y - points[i].y);
                        const maxD = Math.max(d1, d2, d3);
                        if (maxD < connectionDistance) {
                            drawTriangle(points[i], points[j], points[k], 0.5 * (1 - maxD / connectionDistance));
                        }
                    }
                }
            }
            requestAnimationFrame(animateBG);
        }
        function resizeBG() {
            points.forEach(p => {
                p.x = randomBetween(0, window.innerWidth);
                p.y = randomBetween(0, window.innerHeight);
            });
        }
        window.addEventListener('resize', resizeBG);
        window.addEventListener('DOMContentLoaded', () => {
            for (let i = 0; i < numPoints; i++) points.push(createPoint());
            animateBG();
        });

        // --- Chat logic ---
        const queryInput = document.getElementById("queryInput");
        const sendButton = document.getElementById("sendButton");
        const chatMessages = document.getElementById("chatMessages");

        // === Formatting utils & renderer ===
        function escapeHTML(s) {
            return s.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
        }
        function inlineFormat(s) {
            s = s.replace(/`([^`]+)`/g, (m, code) => `<code>${escapeHTML(code)}</code>`);
            s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            s = s.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            s = s.replace(/\*(.*?)\*/g, '<em>$1</em>');
            return s;
        }

        function formatAgentResponse(md) {
            if (!md) return '';
            const codeBlocks = [];
            md = md.replace(/```([a-zA-Z0-9]*)\n([\s\S]*?)```/g, function(m, lang, code) {
                const id = codeBlocks.length;
                codeBlocks.push(code);
                return '[[[CODEBLOCK_' + id + ']]]';
            });

            const lines = md.replace(/\r/g, '').split('\n');
            let html = '';
            let inList = null; // Can be 'ul', 'ol', 'opt'
            
            const closeList = () => {
                if (inList === 'ul') html += '</ul>';
                else if (inList === 'ol') html += '</ol>';
                else if (inList === 'opt') html += '</ul>';
                inList = null;
            };

            for (const line of lines) {
                const trimmed = line.trim();
                let m;
                if (!trimmed) { closeList(); html += '<br>'; continue; }

                // Ordered list
                if ((m = trimmed.match(/^\d+[\.)]\s+(.+)$/))) {
                    if (inList !== 'ol') { closeList(); html += '<ol class="agent-md-ol-list">'; inList = 'ol'; }
                    html += `<li class="agent-md-ol">${inlineFormat(m[1])}</li>`;
                }
                // Unordered list (hyphen or asterisk)
                else if ((m = trimmed.match(/^([-*])\s+(.+)$/))) {
                    if (inList !== 'ul') { closeList(); html += '<ul class="agent-md-ul-list">'; inList = 'ul'; }
                    html += `<li class="agent-md-ul">${inlineFormat(m[2])}</li>`;
                }
                // Option list (A) B) etc)
                else if ((m = trimmed.match(/^([A-Z])\)\s+(.+)$/))) {
                    if (inList !== 'opt') { closeList(); html += '<ul class="agent-md-option-list">'; inList = 'opt'; }
                    html += `<li class="agent-md-option">${m[1]}) ${inlineFormat(m[2])}</li>`;
                }
                // Headings
                else if ((m = trimmed.match(/^#{1,3}\s+(.*)$/))) {
                    closeList();
                    html += `<h3 class="agent-md-heading">${inlineFormat(m[1])}</h3>`;
                }
                // Code block placeholder
                else if (trimmed.startsWith('[[[CODEBLOCK_')) {
                    closeList();
                    html += trimmed;
                }
                // Paragraph
                else {
                    closeList();
                    html += `<p>${inlineFormat(line)}</p>`;
                }
            }

            closeList();
            
            html = html.replace(/\[\[\[CODEBLOCK_(\d+)\]\]\]/g, (m, idx) => {
                const code = codeBlocks[Number(idx)] || '';
                return `<pre><code class="language-plaintext">${escapeHTML(code.trim())}</code></pre>`;
            });

            return DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
        }

        // Add custom styles for markdown
        const style = document.createElement('style');
        style.innerHTML = `
        .agent-md-heading { font-size: 1.18em; font-weight: bold; color: #a78bfa; margin: 0.7em 0 0.3em 0; }
        .agent-md-ol-list, .agent-md-ul-list, .agent-md-option-list { margin: 0.5em 0 0.5em 1.2em; padding-left: 1.2em; }
        .agent-md-ol, .agent-md-ul, .agent-md-option { margin: 0.2em 0; font-size: 1.07em; }
        .agent-md-option { color: #f472b6; font-weight: 500; }
        pre { background-color: #1e1e3e; padding: 1rem; border-radius: 0.5rem; margin: 0.8rem 0; font-size: 0.95em; overflow-x: auto; }
        code { font-family: 'Courier New', Courier, monospace; }
        pre code { color: #d4d4d4; }
        `;
        document.head.appendChild(style);

        function addUserMessage(text) {
            const row = document.createElement('div');
            row.classList.add('message-row');
            const bubble = document.createElement('div');
            bubble.classList.add('user-message');
            bubble.textContent = text;
            row.appendChild(bubble);
            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // --- File upload logic ---
        let selectedFiles = [];
        const fileInput = document.getElementById('file-upload-area');
        const chatInputBar = document.querySelector('.chat-input-bar');

        // Preview area for files
        let filePreviewDiv = document.createElement('div');
        filePreviewDiv.style.display = 'flex';
        filePreviewDiv.style.gap = '0.5rem';
        filePreviewDiv.style.margin = '0.5rem 0 0.2rem 0';
        filePreviewDiv.style.alignItems = 'center';
        chatInputBar.parentNode.insertBefore(filePreviewDiv, chatInputBar);

        fileInput.addEventListener('change', async function() {
            selectedFiles = Array.from(fileInput.files);
            filePreviewDiv.innerHTML = '';
            for (const file of selectedFiles) {
                let el;
                if (file.type.startsWith('image/')) {
                    el = document.createElement('img');
                    el.style.maxWidth = '2.5rem';
                    el.style.maxHeight = '2.5rem';
                    el.style.borderRadius = '0.5rem';
                    el.style.border = '1px solid #3a2a5a';
                    el.title = file.name;
                    el.src = await new Promise(res => {
                        const reader = new FileReader();
                        reader.onload = e => res(e.target.result);
                        reader.readAsDataURL(file);
                    });
                } else {
                    el = document.createElement('span');
                    el.textContent = file.name;
                    el.style.background = '#23232e';
                    el.style.color = '#a78bfa';
                    el.style.fontSize = '0.95em';
                    el.style.padding = '0.2rem 0.7rem';
                    el.style.borderRadius = '0.5rem';
                    el.style.border = '1px solid #3a2a5a';
                }
                filePreviewDiv.appendChild(el);
            }
        });

        async function encodeFiles(files) {
            const arr = [];
            for (const file of files) {
                const base64 = await new Promise(res => {
                    const reader = new FileReader();
                    reader.onload = e => res(e.target.result.split(',')[1]);
                    reader.readAsDataURL(file);
                });
                arr.push({
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    data: base64
                });
            }
            return arr;
        }

        async function sendMessage() {
            const text = queryInput.value.trim();
            if (!text && selectedFiles.length === 0) return;
            addUserMessage(text);
            queryInput.value = '';
            queryInput.focus();

            // Show file preview in user message (optional, can be improved)
            if (selectedFiles.length > 0) {
                const row = document.createElement('div');
                row.classList.add('message-row');
                const bubble = document.createElement('div');
                bubble.classList.add('user-message');
                for (const file of selectedFiles) {
                    if (file.type.startsWith('image/')) {
                        const img = document.createElement('img');
                        img.style.maxWidth = '2.5rem';
                        img.style.maxHeight = '2.5rem';
                        img.style.borderRadius = '0.5rem';
                        img.style.marginRight = '0.3rem';
                        img.title = file.name;
                        img.src = await new Promise(res => {
                            const reader = new FileReader();
                            reader.onload = e => res(e.target.result);
                            reader.readAsDataURL(file);
                        });
                        bubble.appendChild(img);
                    } else {
                        const span = document.createElement('span');
                        span.textContent = file.name;
                        span.style.background = '#23232e';
                        span.style.color = '#a78bfa';
                        span.style.fontSize = '0.95em';
                        span.style.padding = '0.2rem 0.7rem';
                        span.style.borderRadius = '0.5rem';
                        span.style.marginRight = '0.3rem';
                        span.title = file.name;
                        bubble.appendChild(span);
                    }
                }
                row.appendChild(bubble);
                chatMessages.appendChild(row);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Create a row for the agent's streaming response
            const row = document.createElement('div');
            row.classList.add('message-row');
            const agentMessageDiv = document.createElement('div');
            agentMessageDiv.classList.add('agent-message');
            // Add copy button (hidden initially)
            const copyBtn = document.createElement('button');
            copyBtn.innerHTML = '<svg width="26" height="26" viewBox="0 0 24 24" fill="none"><rect x="5" y="9" width="10" height="10" rx="2" stroke="#a78bfa" stroke-width="2"/><rect x="9" y="5" width="10" height="10" rx="2" fill="none" stroke="#a78bfa" stroke-width="2"/></svg>';
            copyBtn.title = 'Copy response';
            copyBtn.style.background = 'none';
            copyBtn.style.border = 'none';
            copyBtn.style.cursor = 'pointer';
            copyBtn.style.margin = '0.7rem auto 0 auto';
            copyBtn.style.display = 'block';
            copyBtn.style.padding = '0.2rem';
            copyBtn.style.transition = 'background 0.15s';
            copyBtn.addEventListener('click', function(e) {
                e.preventDefault();
                const temp = document.createElement('textarea');
                temp.value = agentMessageDiv.textContent;
                document.body.appendChild(temp);
                temp.select();
                document.execCommand('copy');
                document.body.removeChild(temp);
                copyBtn.innerHTML = '✓';
                setTimeout(() => {
                    copyBtn.innerHTML = '<svg width="26" height="26" viewBox="0 0 24 24" fill="none"><rect x="5" y="9" width="10" height="10" rx="2" stroke="#a78bfa" stroke-width="2"/><rect x="9" y="5" width="10" height="10" rx="2" fill="none" stroke="#a78bfa" stroke-width="2"/></svg>';
                }, 1200);
            });
            copyBtn.style.visibility = 'hidden';
            // Wrapper for agent message and button
            const agentMsgWrapper = document.createElement('div');
            agentMsgWrapper.style.display = 'flex';
            agentMsgWrapper.style.flexDirection = 'column';
            agentMsgWrapper.style.alignItems = 'flex-start';
            agentMsgWrapper.appendChild(agentMessageDiv);
            agentMsgWrapper.appendChild(copyBtn);
            row.appendChild(agentMsgWrapper);
            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Show copy button only when response is fully shown
            let lastDisplayText = '';
            const observer = new MutationObserver(() => {
                if (agentMessageDiv.innerHTML !== lastDisplayText) {
                    lastDisplayText = agentMessageDiv.innerHTML;
                    // If streaming is done, show button
                    if (typeof isStreaming !== 'undefined' && !isStreaming) {
                        copyBtn.style.visibility = 'visible';
                        observer.disconnect();
                    }
                }
            });
            observer.observe(agentMessageDiv, { childList: true, subtree: true, characterData: true });

            // Prepare files for sending
            let filesData = [];
            if (selectedFiles.length > 0) {
                filesData = await encodeFiles(selectedFiles);
            }
            // Clear preview and selection
            filePreviewDiv.innerHTML = '';
            fileInput.value = '';
            selectedFiles = [];

            try {
                const res = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text, files: filesData })
                });

                if (!res.ok) {
                    throw new Error(`Server error: ${res.statusText}`);
                }

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';
                let buffer = '';
                let typingInterval = null;
                let displayIndex = 0;
                let displayText = '';
                let isStreaming = true;

                function showTyping() {
                    if (displayIndex < displayText.length) {
                        agentMessageDiv.innerHTML = formatAgentResponse(displayText.slice(0, displayIndex + 1));
                        displayIndex++;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else {
                        clearInterval(typingInterval);
                        typingInterval = null;
                        if (!isStreaming) {
                            agentMessageDiv.innerHTML = formatAgentResponse(displayText);
                        }
                    }
                }

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    let match;
                    const jsonRegex = /\{[^}]*\}/g;
                    let lastIndex = 0;
                    while ((match = jsonRegex.exec(buffer)) !== null) {
                        try {
                            let obj = JSON.parse(match[0]);
                            if (obj.response) {
                                fullResponse += obj.response;
                                displayText = fullResponse;
                                if (!typingInterval) {
                                    typingInterval = setInterval(showTyping, 7);
                                }
                            }
                        } catch (e) {}
                        lastIndex = jsonRegex.lastIndex;
                    }
                    buffer = buffer.slice(lastIndex);
                    jsonRegex.lastIndex = 0;
                }
                isStreaming = false;
                if (!typingInterval) {
                    agentMessageDiv.innerHTML = formatAgentResponse(fullResponse);
                }
            } catch (err) {
                console.error('Fetch error:', err);
                agentMessageDiv.innerHTML = formatAgentResponse('⚠️ Error connecting to the server. Please try again.');
            }
        }

        sendButton.addEventListener('click', sendMessage);
        queryInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    </script>
</body>
</html>
